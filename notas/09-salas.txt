Socket io nos permite crear salas, esto es útil si queremos por ejemplo hacer una aplicación de chat o algo por el estilo, en donde cada sala es un chat.

La forma en como hacerlo es muy sencilla, que es con el método join del socket del evento de la conexión.

Desde el cliente, supongamos que tenemos tres botones, en donde cada uno tiene un id, que serán las salas que están disponibled room1, room2 y room3.

    index.html:
      <body>
        <h1>Socket io</h1>
        <ul>
          <li><button id="room1">Room 1</button></li>
          <li><button id="room2">Room 2</button></li>
          <li><button id="room3">Room 3</button></li>
        </ul>
      </body>

Y emitimos una acción "channel_join" al hacer click a cualquiera a esos botones, en donde enviamos la sala a la cual dimos click, que lo sacamos del id del botón

    views/index.js: 
      document.querySelectorAll("button").forEach(b => {  
        b.addEventListener("click", (e) => {
          client.emit("channel_join", e.target.id);
        })
      })

Entonces, desde el servidor escuchamos ese evento "channel_join" que nos llega desde el cliente

    index.js: 
      io.on("connection", (socket) => {
        socket.on("channel_join", (channel) => console.log("channel: ", channel)); //room 1, 2 o 3
      });

Y ahora podemos hacer lo que dijimos, unirnos a esa sala con el método join. Si la sala no existe, esta se crea inmediatamente, si la sala ya existe, simplemente nos unimos a ella

    index.js: 
      index.js: 
      io.on("connection", (socket) => {
        socket.on("channel_join", (channel) => {
            socket.join("channel")
        })
      });

Si quisieramos implementar una lógica de envío de mensajes, este sería como que se creó el chat y un usuario esta conectado a una sala, faltaría la lógica de envío de mensajes, pero, al enviar un mensaje como sabremos en el servidor a que sala o canal estamos enviando el mensaje? Socket io nos permite establecer propiedades custom persistentes, es decir, que lo creemos en un evento y que en algún otro evento lo recordemos. 
En este caso nos sirve para poder saber en donde estamos conectados, por lo que podríamos crear una propiedad llamada "connectedRoom" inicializada en el ámbito global para poder usarla en otros eventos, y seteada al momento de recibir en el servidor el evento custom de que un usuario se conectó a un canal

    index.js: 
      index.js: 
      io.on("connection", (socket) => {
        socket.connectedRoom 
        socket.on("channel_join", (channel) => {
            socket.join("channel");
            socket.connectedRoom = channel;
        })
      });


Entonces, ya tenemos la conexión persistente a una sala. Ahora, socket io también nos permite enviar eventos a una sala en específico, con el método "to", nos podríamos valer de este evento para que podamos enviar mensajes a un chat en específico.

Pero primero, el cliente debe enviar un mensaje al servidor, que el servidor procese ese mensaje, y que vuelva a enviar ese mensaje al canal específico con los participantes dentro de la sala.

Primero veamos lo del cliente, haremos un botón con el prompt del navegador para enviar el mensaje, en donde ese prompt lo abrirá un input de tipo botón

    index.html:
      <body>
        <h1>Socket io</h1>
        <ul>
          <li><button id="room1">Room 1</button></li>
          <li><button id="room2">Room 2</button></li>
          <li><button id="room3">Room 3</button></li>
        </ul>
        <input type="button" id="message" />
      </body>

Es importante que primero estemos conectados a un canal para que esto funcione. 
Seguido a eso, una vez conectados a un canal, podemos darle una acción a ese botón, en donde se emitirá un evento de tipo mensaje al enviar la información 

    views/index.js:
      document.getElementById("message").addEventListener("click", () => {
        const message = prompt("Send your message: ");
        client.emit("message", message);
    })

Entonces, desde el servidor recibiremos ese evento, lo procesaremos, y lo volveremos a enviar a la sala a la cual estamos conectados, como dijimos, con el método "to" de la instancia del server de socket io y con nuestra propiedad custom del canal en donde estamos conectados

    index.js: 
      index.js: 
      io.on("connection", (socket) => {
        socket.connectedRoom 
        socket.on("channel_join", (channel) => {
            socket.join("channel");
            socket.connectedRoom = channel;
        })

        socket.on("message", (receivedMessage) => {
            io.to(socket.connectedRoom).emit("message", {
                channel: socket.connectedRoom, 
                message: receivedMessage
            })
        })
      });

Y desde el cliente, escucharemos ese evento que emitió el server, para que el mensaje llegue a todos los participantes de la sala, pero tenemos que tener el HTML de las salas para poder diferenciar los mensajes de en que sala fueron emitidos, en donde haremos una clase por cada sala para poder inyectar el mensaje en la sala correcta.
Es importante recalcar que el cliente tiene que estar conectado a la sala que llega el mensaje para poder recibirlo, porque el mensaje solo es enviado a los participantes de la sala

    index.html: 
      <body>
        <h1>Socket io</h1>
        <div class="room room1">
            <p>Room 1</p>
        </div>
        <div class="room room2">
            <p>Room 2</p>
        </div>
        <div class="room room3">
            <p>Room 3</p>
        </div>
        <ul>
            <li><button id="room1">Room 1</button></li>
            <li><button id="room2">Room 2</button></li>
            <li><button id="room3">Room 3</button></li>
        </ul>
        <input type="button" id="message" value="Send new message" />
      </body>

Entonces ya tenemos el HTML y faltaría poder agregar el mensaje que llega al HTML de la sala

    views/index.js:
      const client = io();
      document.getElementById("message").addEventListener("click", () => {
        const message = prompt("Send your message: ");
        client.emit("message", message);
      })

      client.on("message", (receivedMessage) => {
        const newMessage = document.createElement(p);
        newMessage.textContent = receivedMessage.message;
        document.querySelector(`.${receivedMessage.channel}`).appendChild(newMessage);
      })

Si por algún motivo quisieramos que el cliente solo este conectado a una sala a la vez, podríamos usar el método leave del evento del socket cuando este se conecta a una sala, en donde dejaremos la sala que hayamos persistido antes

    index.js: 
      index.js: 
      io.on("connection", (socket) => {
        socket.connectedRoom 
        socket.on("channel_join", (channel) => {
            socket.leave(socket.connectedRoom);
            socket.join("channel");
            socket.connectedRoom = channel;
        })

        socket.on("message", (receivedMessage) => {
            io.to(socket.connectedRoom).emit("message", {
                channel: socket.connectedRoom, 
                message: receivedMessage
            })
        })
      });